#include "coord/base/base_router.h"
#include "coord/base/base_notify.h"
#include "coord/base/base_request.h"
#include "coord/base/base_response.h"
#include "coord/component/script_component.h"
#include "util/date/date.h"
#include "coord/coord.h"

namespace coord {

//CC_IMPLEMENT(base_router, "coord::base_router")

base_router_handler::~base_router_handler() {
    if(this->ref >= 0) {
        luaL_unref(this->coord->Script->L, LUA_REGISTRYINDEX, this->ref);
        this->ref = 0;
    }
}

void base_router_handler::recvRequest(base_request* request) {
    if(this->recvRequestFunc != nullptr){
        this->recvRequestFunc(request);
    } 
} 

void base_router_handler::recvNotify(base_notify* notify) {
    if(this->recvNotifyFunc != nullptr){
        this->recvNotifyFunc(notify);
    } 
} 

base_router::base_router(Coord* coord){
    this->coord = coord;
}

base_router::~base_router(){

}

base_router_handler* base_router::searchHandler(const char* event, const char* route) {
    base_router_tree* tree = this->getTree(event);
    auto it = tree->handlerDict.find(route);
    if (it == tree->handlerDict.end()){
        return nullptr;
    } 
    return it->second;
}

void base_router::recvNotify(base_notify* notify) {
    this->coord->CoreLogDebug("[%s] recvNotify %s", this->TypeName(), notify->TypeName());
    base_router_handler* handler = this->searchHandler("NOTIFY", notify->route.c_str());
    if(handler == nullptr){
        this->coord->CoreLogDebug("[%s] recvNotify %s failed, error='router not found', path=%s", this->TypeName(), notify->TypeName(), notify->route.c_str());
        return;
    }
    uint64_t t1 = this->coord->NanoTime();
    handler->recvNotify(notify);
    handler->times++;
    handler->consumeTime += (this->coord->NanoTime() - t1);
} 

void base_router::recvRequest(base_request* request) {
    this->coord->CoreLogDebug("[base_router] recvRequest %s", request->TypeName());
    base_router_handler* handler = this->searchHandler("REQUEST", request->route.c_str());
    if(handler == nullptr){
        this->coord->CoreLogDebug("[%s] recvRequest failed, error='router not found', path=%s", this->TypeName(), request->route.c_str());
        base_response* response = request->GetResponse();
        response->String("Not Found");
        response->Reject(404);
    } else {
        uint64_t t1 = this->coord->NanoTime();
        handler->recvRequest(request);
        handler->times++;
        handler->consumeTime += (this->coord->NanoTime() - t1);
    }
}

void base_router::Trace() {
    for(auto const& it : this->trees){
        auto event = it.first;
        auto tree = it.second;
        for(auto const& it1 : tree->handlerDict) {
            auto handler = it1.second;
            uint64_t averageTime = handler->times <= 0 ? 0 : (handler->consumeTime/handler->times);
            this->coord->CoreLogDebug("[%s] %10s | %10d | %10s | %s", this->TypeName(), event.c_str(), handler->times, date::FormatNano(averageTime), it1.first.c_str());
        }
    }
}

bool base_router::Request(const char* route, RouterRecvRequestFunc func){
    if(func == nullptr) {
        return this->addRoute("REQUEST", route, nullptr);
    } else {
        base_router_handler* handler = new base_router_handler(this->coord, func);
        return this->addRoute("REQUEST", route, handler);
    }
}

bool base_router::Request(const char* route, ScriptComponent* object, int ref) {
    if(object == nullptr) {
        return this->addRoute("REQUEST", route, nullptr);
    } else {
        base_router_handler* handler = new base_router_handler(this->coord, std::bind(&ScriptComponent::recvRequest, object, std::placeholders::_1, "recvRequest", ref), ref);
        return this->addRoute("REQUEST", route, handler);
    }
}

int base_router::Request(lua_State* L) {
#ifndef TOLUA_RELEASE
    tolua_Error tolua_err;
    if (
        !tolua_isusertype(L,1, this->TypeName(),0,&tolua_err) ||
        !tolua_isstring(L,2,0,&tolua_err) ||
        !tolua_isusertype(L,3,"coord::ScriptComponent",0,&tolua_err) ||
        !tolua_isfunction(L,4,0,&tolua_err) ||
        !tolua_isnoobj(L,5,&tolua_err)
    )
        goto tolua_lerror;
    else
#endif
    {
        const char* route = (const char*) tolua_tostring(L, 2, 0);
        coord::ScriptComponent* object = ((coord::ScriptComponent*)  tolua_tousertype(L,3,0));
        lua_pushvalue(L, 4);
        int ref =  luaL_ref(L, LUA_REGISTRYINDEX);
        if (ref < 0) {
            tolua_error(L, "error in function 'Request'.\nattempt to set a nil function", NULL);
            return 0;
        }
        bool result = this->Request(route, object, ref);
        if(!result) {
            luaL_unref(L, LUA_REGISTRYINDEX, ref);
        }
        tolua_pushboolean(L, result);
    }
    return 1;
#ifndef TOLUA_RELEASE
    tolua_lerror:
    tolua_error(L,"#ferror in function 'Request'.",&tolua_err);
    return 0;
#endif
}

bool base_router::Notify(const char* path, RouterRecvNotifyFunc func){
    if(func == NULL) {
        return this->addRoute("NOTIFY", path, NULL);
    } else {
        base_router_handler* handler = new base_router_handler(this->coord, func);
        return this->addRoute("NOTIFY", path, handler);
    }
}

bool base_router::Notify(const char* path, ScriptComponent* object, int ref) {
    if(object == NULL) {
        return this->addRoute("NOTIFY", path, NULL);
    } else {
        base_router_handler* handler = new base_router_handler(this->coord, std::bind(&ScriptComponent::recvNotify, object, std::placeholders::_1, "recvNotify", ref), ref);
        return this->addRoute("NOTIFY", path, handler);
    }
}

int base_router::Notify(lua_State* L) {
#ifndef TOLUA_RELEASE
    tolua_Error tolua_err;
    if (
        !tolua_isusertype(L,1,this->TypeName(),0,&tolua_err) ||
        !tolua_isstring(L,2,0,&tolua_err) ||
        !tolua_isusertype(L,3,"coord::ScriptComponent",0,&tolua_err) ||
        !tolua_isfunction(L,4,0,&tolua_err) ||
        !tolua_isnoobj(L,5,&tolua_err)
    )
        goto tolua_lerror;
    else
#endif
    {
        const char* route = (const char*) tolua_tostring(L, 2, 0);
        coord::ScriptComponent* object = ((coord::ScriptComponent*)  tolua_tousertype(L,3,0));
        lua_pushvalue(L, 4);
        int ref =  luaL_ref(L, LUA_REGISTRYINDEX);
        if (ref < 0) {
            tolua_error(L, "error in function 'Notify'.\nattempt to set a nil function", NULL);
            return 0;
        }
        bool result = this->Notify(route, object, ref);
        if(!result) {
            luaL_unref(L, LUA_REGISTRYINDEX, ref);
        }
        tolua_pushboolean(L, result);
    }
    return 1;
#ifndef TOLUA_RELEASE
    tolua_lerror:
    tolua_error(L,"#ferror in function 'Notify'.",&tolua_err);
    return 0;
#endif
}

bool base_router::addRoute(const char* event, const char* route, base_router_handler* handler) {
    base_router_tree* tree = this->getTree(event);
    //this->coord->CoreLogDebug("[base_router] add route, event=%-10s, route=%-64s, handler=0x%x", event, route, handler);
    auto it = tree->handlerDict.find(route);
    if (it != tree->handlerDict.end()) {
        delete it->second;
        tree->handlerDict.erase(it);
        tree->handlerDict[route] = handler;
    } else {
        tree->handlerDict[route] = handler;
    }
    return true;
} 

base_router_tree* base_router::getTree(const char* event) {
    const auto it = this->trees.find(event);
    if (it == this->trees.end()){
        base_router_tree* tree = new base_router_tree();
        this->trees[event] = tree;
        return tree;
    } else {
        return it->second;
    }
}


} 
